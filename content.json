[{"title":"关于学习新技术的方法和反思","date":"2017-11-02T12:49:23.000Z","path":"2017/11/02/my-mind-pattern01/","link":"","excerpt":"在这个技术日新月异的时代，每天都有很多技术过时，同时也会很多新技术被发明出来，作为一名技术人员，在学习新技术时，会有自己的一套学习方法。在此将自己的学习方法和反思记录下来。 在面对新技术时，不同的技术人员会根据自己的思维习惯采取不同的学习方法，但总的来说，大体分为两类。第一类是抛开其他因素，直接上手，以最快的速度将新技术运用到实践中，然后再根据自己的情况选择是否要在这门技术上深入下去。而第二类则是先做大量相关的基础铺垫，等基础牢固了，再去学习新技术。对于我而言，会根据不同的情况选择不同的学习方法。在项目紧急的情况下，我会选择第一类方法，以最快的速度将技术运用到实践中，等项目完成之后，再去考虑需不需要在这门技术上深入下去。比如，在一次项目中，需要使用QT开发一个","categories":[{"name":"生活","slug":"生活","permalink":"https://free-free.github.io/categories/生活/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://free-free.github.io/tags/随笔/"}]},{"title":"未送出的礼物(END)","date":"2017-11-02T02:31:33.000Z","path":"2017/11/02/not-send-present/","link":"","excerpt":"","categories":[{"name":"我的她","slug":"我的她","permalink":"https://free-free.github.io/categories/我的她/"}],"tags":[{"name":"礼物","slug":"礼物","permalink":"https://free-free.github.io/tags/礼物/"}]},{"title":"机器学习相关论文(持续更新)","date":"2017-10-30T05:02:05.000Z","path":"2017/10/30/machine-learning-latest-topic-article/","link":"","excerpt":"Dynamic Routing Between Capsules paper : download author : Geoffrey E. Hinton, Sara Sabour and Nicholas Frosst date: September 2017 Reducing the Dimensionality of Data with Neural Networks paper : download author : G. E. Hinton and R. R. Salakhutdinov date : 2006","categories":[{"name":"tech","slug":"tech","permalink":"https://free-free.github.io/categories/tech/"}],"tags":[{"name":"machine-learning","slug":"machine-learning","permalink":"https://free-free.github.io/tags/machine-learning/"}]},{"title":"使用共享状态实现单例模式？","date":"2017-10-30T02:18:47.000Z","path":"2017/10/30/implementation-of-singleton-using-share-state/","link":"","excerpt":"1. 概述之前介绍了3种实现单例模式方法： 使用装饰器实现python单例模式 使用元类实现python 单例模式 使用Python类 __new__ 方法实现单例模式 这种三种实现方法都是我们通常理解的单例模式：即每次创建对象时，都返回同一个对象。但从一个更广的层面上讲，单例模式不仅可以理解为一个类创建的所有对象在内存中都是同一个对象，也可以理解为一个类的所有对象都共享同一状态。共享状态之后，虽然类每次创建的对象都不同，但是它们有一个共享的状态，一个对象对自己的状态操作，也会通过共享状态反映到其他的对象上[1]，这样做也能达到传统单例模式要求的功能。对于Python而言，所谓共享状态是将每一个对象的__dict__指向同一个字典。这种通过共享状态实现单例模式的方法被称为Borg或者Monostate。","categories":[{"name":"tech","slug":"tech","permalink":"https://free-free.github.io/categories/tech/"}],"tags":[{"name":"python","slug":"python","permalink":"https://free-free.github.io/tags/python/"}]},{"title":"使用Python类__new__方法实现单例模式","date":"2017-10-29T10:35:10.000Z","path":"2017/10/29/implemenation-of-singleton-using-new-method/","link":"","excerpt":"1.概述前两篇文章分别介绍了使用装饰器实现单例模式和使用元类实现单例模式。这篇文章介绍使用Python类的__new__方法来实现单例模式。当谈及Python类实例化对象时，不得不提到创建对象过程中涉及到的两个方法__init__和__new__。在Python的类中，__init__method是对象初始化器，而且__new__method才是真正的构造method，它负责创建对象，并将创建的对象返回。对象的创建流程如下：","categories":[{"name":"tech","slug":"tech","permalink":"https://free-free.github.io/categories/tech/"}],"tags":[{"name":"python","slug":"python","permalink":"https://free-free.github.io/tags/python/"}]},{"title":"写给她的第一封信","date":"2017-10-26T12:16:46.000Z","path":"2017/10/26/first-letter-to-her/","link":"","excerpt":"每当看见电影里男主给女主写信的时候，心里特别激动，想着以后自己的女朋友收到我写给她信的时候应该会很开心、很幸福吧。","categories":[{"name":"我的她","slug":"我的她","permalink":"https://free-free.github.io/categories/我的她/"}],"tags":[{"name":"for-her","slug":"for-her","permalink":"https://free-free.github.io/tags/for-her/"}]},{"title":"markdown集成mathjax","date":"2017-10-24T10:42:57.000Z","path":"2017/10/24/integrate-with-mathjax-in-markdown/","link":"","excerpt":"概述​ 之前一直使用markdown写文章，使用的都是markdown常规的语法，并没有考虑过怎样使用markdown插入数学公式，直到最近需要在文章中插入数学公式时，才认真考虑怎样使用markdown插入数学公式。在网上查了之后，发现markdown并不支持直接插入数学公式，需要借助第三方来插入，在草草试用几种插入数学公式的方式之后，个人觉得使用MathJax插入数学公式比较方便、简洁，插入的数学公式也很漂亮。遂在这里把怎样使用MathJax在markdown中插入数学公式的方法和基本的MathJax的语法记录下来，以便之后学习，如有什么错误请大家指教。 MathJax1. MathJax简介MathJax是一个javascript软件包，它允许你通过LaTex、MathML或者AsciiMath语法在网页中插入数学公式，并通过javascript处理之后产生HTML、SVG或者MathML equations 等可视化的格式，以便在浏览器中浏览。","categories":[{"name":"tech","slug":"tech","permalink":"https://free-free.github.io/categories/tech/"}],"tags":[{"name":"math","slug":"math","permalink":"https://free-free.github.io/tags/math/"}]},{"title":"从ubuntu16.04/ubuntu17.04升级到ubuntu17.10(译)","date":"2017-10-23T14:15:31.000Z","path":"2017/10/23/upgrade-ubuntu17-10-from-ubuntu16-04-or-ubuntu17-04/","link":"","excerpt":"最近ubuntu官方发布了又一个LTS：ubuntu17.10。ubuntu17.10有着很大的变化，引入了很多的新的技术。ubuntu17.10是ubuntu第一个使用GNOME Shell作为默认桌面的版本。自己也想着感受一下ubuntu17.10引入的新技术，在这里翻译一篇从ubuntu16.04/ubuntu17.04升级到ubuntu17.10的教程。原本在这里","categories":[{"name":"tech","slug":"tech","permalink":"https://free-free.github.io/categories/tech/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://free-free.github.io/tags/linux/"}]},{"title":"送给她的第一个礼物","date":"2017-10-21T12:42:37.000Z","path":"2017/10/21/myher-first-presents/","link":"","excerpt":"","categories":[{"name":"我的她","slug":"我的她","permalink":"https://free-free.github.io/categories/我的她/"}],"tags":[{"name":"礼物","slug":"礼物","permalink":"https://free-free.github.io/tags/礼物/"}]},{"title":"ubuntu下绑定串口设备名","date":"2017-10-20T10:44:39.000Z","path":"2017/10/20/binding-serialport-device-name/","link":"","excerpt":"1. 为什么我需要绑定串口设备名 最近在ubuntu上使用串口进行通信时，由于硬件的原因需要不时的拔掉串口然后再重新插上，可是每次拔掉之后再重新插上去发现串口设备名由原来的/dev/ttyUSB0变为/dev/ttyUSB1，导致每次重新插上串口时都需要在程序中改变串口设备名，来回这么折腾搞得我很毛躁呀。这就是为什么我要去绑定串口设备名的原因，目的很单纯，被造的。","categories":[{"name":"tech","slug":"tech","permalink":"https://free-free.github.io/categories/tech/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://free-free.github.io/tags/linux/"}]},{"title":"python黑魔法－元类","date":"2017-10-15T10:46:31.000Z","path":"2017/10/15/python-black-magic-metaclass/","link":"","excerpt":"","categories":[{"name":"tech","slug":"tech","permalink":"https://free-free.github.io/categories/tech/"}],"tags":[{"name":"python","slug":"python","permalink":"https://free-free.github.io/tags/python/"}]},{"title":"使用元类实现python 单例模式","date":"2017-10-14T11:47:18.000Z","path":"2017/10/14/implementation-of-singleton-using-metaclass/","link":"","excerpt":"1.概述 上一篇博客介绍了使用装饰器实现python单例模式，这篇博客将介绍使用python的黑魔法－－元类(Metaclass)来实现python的单例模式。对于知道元类的pythoner，使用元类实现单例模式应该是很简单的。然而对于不知道python元类的同行来说，理解起来可能要吃力一点。为此，接下来将先介绍python的元类，然后再介绍怎样使用元类实现单例模式。如果有什么不妥的地方，敬请大神们多多指点。","categories":[{"name":"tech","slug":"tech","permalink":"https://free-free.github.io/categories/tech/"}],"tags":[{"name":"python","slug":"python","permalink":"https://free-free.github.io/tags/python/"}]},{"title":"python单例模式:装饰器版","date":"2017-10-11T10:36:47.000Z","path":"2017/10/11/implementation-of-singleton-using-decrator/","link":"","excerpt":"使用装饰器实现python单例模式1.概述不同的编程语言所支持的语言特性不一样，导致实现单例模式的方式也各不相同。python作为一门动态语言，有很大的灵活性，实现的单例模式的方式也不尽相同，在这里总结一下python实现单例模式的方法，以便之后学习。本系列主要简述4种方式实现单例模式: 装饰器实现单例模式1 元类实现单例模式 __new__方法实现单例模式 共享__dict__实现单例模式 本节主要简述使用装饰器实现单例模式。","categories":[{"name":"tech","slug":"tech","permalink":"https://free-free.github.io/categories/tech/"}],"tags":[{"name":"python","slug":"python","permalink":"https://free-free.github.io/tags/python/"}]},{"title":"lua5.2获取函数可变参数","date":"2017-10-11T10:22:41.000Z","path":"2017/10/11/access-variable-parameter-in-lua5-2/","link":"","excerpt":"Lua(&gt;=5.2) 可变参数获取在Lua5.2之前，函数的可变参数在函数调用的时候自动获取并放在arg变量(table)中，要访问每一可变参数只需要通过arg[0], arg[1],…..arg[m]来获取，并且arg中还有一个域n负责记录可变参数的个数，示例代码如下所示： 1234567function myadd(a, b, ...) local sum = a + b for i = 1,arg.n do sum = sum + arg[n] end return sumend","categories":[{"name":"tech","slug":"tech","permalink":"https://free-free.github.io/categories/tech/"}],"tags":[{"name":"lua","slug":"lua","permalink":"https://free-free.github.io/tags/lua/"}]},{"title":"say_hello","date":"2017-09-15T10:41:29.000Z","path":"2017/09/15/say-hello/","link":"","excerpt":"","categories":[{"name":"tech","slug":"tech","permalink":"https://free-free.github.io/categories/tech/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://free-free.github.io/tags/生活/"}]}]